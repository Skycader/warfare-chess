<!DOCTYPE html>
<html lang="ru">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Chess: Modern Warfare</title>
    <style>
      body {
        font-family: Arial, sans-serif;
        display: flex;
        flex-direction: column;
        align-items: center;
        background: #0a0a0a;
        margin: 0;
        padding: 20px;
        color: #fff;
      }
      #status {
        font-size: 22px;
        margin: 15px 0;
        font-weight: bold;
        color: #ffcc00;
        text-shadow: 0 0 8px rgba(255, 204, 0, 0.7);
      }
      #chessboard {
        display: grid;
        grid-template-columns: repeat(8, 60px);
        grid-template-rows: repeat(8, 60px);
        border: 3px solid #555;
        box-shadow: 0 0 20px rgba(200, 0, 0, 0.6);
        position: relative;
      }
      .square {
        width: 60px;
        height: 60px;
        display: flex;
        justify-content: center;
        align-items: center;
        font-size: 40px;
        cursor: pointer;
        position: relative;
        z-index: 2;
        font-family: "Segoe UI Symbol", "Noto Sans Symbols", "Arial Unicode MS",
          sans-serif;
      }
      .white {
        background-color: #f0d9b5;
      }
      .black {
        background-color: #b58863;
      }
      .highlight {
        box-shadow: inset 0 0 0 4px #00ccff;
      }
      .move-possible {
        box-shadow: inset 0 0 0 4px #00ff66;
      }
      .target {
        box-shadow: inset 0 0 0 4px #ff3333;
      }
      .piece-white {
        color: white;
        text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.6);
      }
      .piece-black {
        color: black;
        text-shadow: 1px 1px 2px rgba(255, 255, 255, 0.4);
      }
      .laser {
        position: absolute;
        background: linear-gradient(
          90deg,
          transparent,
          #ff0000,
          #ff9900,
          #ff0000,
          transparent
        );
        height: 4px;
        z-index: 10;
        transform-origin: left center;
        animation: laserShoot 0.3s forwards;
      }
      @keyframes laserShoot {
        0% {
          width: 0;
          opacity: 1;
        }
        100% {
          width: var(--laser-length);
          opacity: 0;
        }
      }
      .blood {
        position: absolute;
        font-size: 28px;
        z-index: 20;
        animation: bloodSplatter 1s forwards;
        pointer-events: none;
        color: #ff0000;
        font-weight: bold;
        text-shadow: 0 0 6px #ff0000;
      }
      @keyframes bloodSplatter {
        0% {
          transform: scale(0.2);
          opacity: 1;
        }
        70% {
          transform: scale(1.2);
          opacity: 1;
        }
        100% {
          transform: scale(1);
          opacity: 0;
        }
      }
      .info {
        margin-top: 15px;
        color: #ccc;
        max-width: 540px;
        text-align: center;
        line-height: 1.4;
      }
      .controls {
        margin-top: 10px;
        font-size: 14px;
        color: #aaa;
      }
      h1 {
        font-family: "Courier New", monospace;
        letter-spacing: 1px;
        text-transform: uppercase;
        color: #ddd;
        margin: 10px 0;
      }

      /* PGN Button */
      #pgn-button {
        position: fixed;
        bottom: 20px;
        right: 20px;
        background: #333;
        color: #ffcc00;
        border: none;
        width: 40px;
        height: 40px;
        border-radius: 50%;
        font-size: 20px;
        cursor: pointer;
        box-shadow: 0 0 8px rgba(255, 204, 0, 0.5);
        z-index: 1000;
      }
      #pgn-button:hover {
        background: #444;
        transform: scale(1.1);
      }

      /* PGN Window */
      #pgn-window {
        display: none;
        position: fixed;
        bottom: 80px;
        right: 20px;
        width: 300px;
        height: 200px;
        background: #1a1a1a;
        border: 2px solid #555;
        border-radius: 8px;
        box-shadow: 0 0 15px rgba(0, 0, 0, 0.7);
        z-index: 2000;
        resize: both;
        overflow: hidden;
        flex-direction: column;
      }
      #pgn-header {
        padding: 8px 12px;
        background: #2a2a2a;
        cursor: move;
        user-select: none;
        display: flex;
        justify-content: space-between;
        align-items: center;
        font-weight: bold;
        color: #ffcc00;
      }
      #pgn-close {
        background: none;
        border: none;
        color: #ff5555;
        font-size: 18px;
        cursor: pointer;
      }
      #pgn-content {
        flex: 1;
        padding: 10px;
        color: #ccc;
        font-family: monospace;
        font-size: 13px;
        overflow: auto;
        white-space: pre-wrap;
      }
    </style>
  </head>
  <body>
    <h1>Chess: Modern Warfare</h1>
    <div id="status">–•–æ–¥ –±–µ–ª—ã—Ö</div>
    <div id="chessboard"></div>
    <div class="controls">
      –õ–ö–ú ‚Äî –≤—ã–±—Ä–∞—Ç—å —Ñ–∏–≥—É—Ä—É ‚Üí –õ–ö–ú = <b>—Ö–æ–¥</b> | –ü–ö–ú –ø–æ —Ñ–∏–≥—É—Ä–µ ‚Üí –ü–ö–ú –ø–æ —Ü–µ–ª–∏ =
      <b>–≤—ã—Å—Ç—Ä–µ–ª</b>
    </div>
    <div class="info">–£–Ω–∏—á—Ç–æ–∂—å—Ç–µ –∫–æ—Ä–æ–ª—è –ø—Ä–æ—Ç–∏–≤–Ω–∏–∫–∞.</div>

    <button id="pgn-button">üìö</button>
    <div id="pgn-window">
      <div id="pgn-header">
        <span>PGN Notation</span>
        <button id="pgn-close">√ó</button>
      </div>
      <div id="pgn-content"></div>
    </div>

    <script>
      const initialBoard = [
        ["r", "n", "b", "q", "k", "b", "n", "r"],
        ["p", "p", "p", "p", "p", "p", "p", "p"],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        [null, null, null, null, null, null, null, null],
        ["P", "P", "P", "P", "P", "P", "P", "P"],
        ["R", "N", "B", "Q", "K", "B", "N", "R"],
      ];

      let board = JSON.parse(JSON.stringify(initialBoard));
      let currentPlayer = "white";
      let selectedPiece = null;
      let mode = null;
      let possibleMoves = [];
      let shootTargets = [];
      let moveHistory = [];
      let moveNumber = 1;

      let castling = {
        whiteKingside: true,
        whiteQueenside: true,
        blackKingside: true,
        blackQueenside: true,
      };

      const pieceSymbols = {
        K: "‚ôö",
        Q: "‚ôõ",
        R: "‚ôú",
        B: "‚ôù",
        N: "‚ôû",
        P: "‚ôü",
        k: "‚ôö",
        q: "‚ôõ",
        r: "‚ôú",
        b: "‚ôù",
        n: "‚ôû",
        p: "‚ôü",
      };

      function isWhite(piece) {
        return piece && piece === piece.toUpperCase();
      }
      function isBlack(piece) {
        return piece && piece === piece.toLowerCase();
      }
      function isEnemy(piece, forWhite) {
        return piece && (forWhite ? isBlack(piece) : isWhite(piece));
      }
      function isFriend(piece, forWhite) {
        return piece && !isEnemy(piece, forWhite);
      }

      function pieceToName(piece) {
        const map = {
          K: "King",
          Q: "Queen",
          R: "Rook",
          B: "Bishop",
          N: "Knight",
          P: "Pawn",
        };
        return map[piece.toUpperCase()] || "Piece";
      }

      function addToPGN(text) {
        if (currentPlayer === "white") {
          moveHistory.push(`${moveNumber}. ${text}`);
          moveNumber++;
        } else {
          const last = moveHistory[moveHistory.length - 1];
          if (last && last.includes(".")) {
            moveHistory[moveHistory.length - 1] = last + ` ${text}`;
          } else {
            moveHistory.push(`... ${text}`);
          }
        }
        updatePGNDisplay();
      }

      function logShot(fromRow, fromCol, toRow, toCol) {
        const cols = "abcdefgh";
        const fromSquare = cols[fromCol] + (8 - fromRow);
        const toSquare = cols[toCol] + (8 - toRow);
        const notation = `{ ${fromSquare}üèπ${toSquare} }`;
        addToPGN(notation);
      }

      function updatePGNDisplay() {
        const content = document.getElementById("pgn-content");
        content.textContent = moveHistory.join("\n");
        content.scrollTop = content.scrollHeight;
      }

      function canCastle(white, kingside) {
        if (white) {
          if (kingside) {
            if (!castling.whiteKingside) return false;
            if (board[7][4] !== "K" || board[7][7] !== "R") return false;
            if (board[7][5] !== null || board[7][6] !== null) return false;
            return true;
          } else {
            if (!castling.whiteQueenside) return false;
            if (board[7][4] !== "K" || board[7][0] !== "R") return false;
            if (
              board[7][1] !== null ||
              board[7][2] !== null ||
              board[7][3] !== null
            )
              return false;
            return true;
          }
        } else {
          if (kingside) {
            if (!castling.blackKingside) return false;
            if (board[0][4] !== "k" || board[0][7] !== "r") return false;
            if (board[0][5] !== null || board[0][6] !== null) return false;
            return true;
          } else {
            if (!castling.blackQueenside) return false;
            if (board[0][4] !== "k" || board[0][0] !== "r") return false;
            if (
              board[0][1] !== null ||
              board[0][2] !== null ||
              board[0][3] !== null
            )
              return false;
            return true;
          }
        }
      }

      function getValidMoves(row, col, piece) {
        const moves = [];
        const white = isWhite(piece);
        const type = piece.toLowerCase();

        function addDirection(dr, dc, limit = 7) {
          let r = row + dr,
            c = col + dc,
            steps = 0;
          while (r >= 0 && r < 8 && c >= 0 && c < 8 && steps < limit) {
            if (board[r][c] === null) moves.push([r, c]);
            else {
              if (isEnemy(board[r][c], white)) moves.push([r, c]);
              break;
            }
            r += dr;
            c += dc;
            steps++;
          }
        }

        switch (type) {
          case "p":
            const dir = white ? -1 : 1;
            if (
              row + dir >= 0 &&
              row + dir < 8 &&
              board[row + dir][col] === null
            ) {
              moves.push([row + dir, col]);
              if ((white && row === 6) || (!white && row === 1)) {
                if (board[row + 2 * dir][col] === null)
                  moves.push([row + 2 * dir, col]);
              }
            }
            for (let dc of [-1, 1]) {
              const r2 = row + dir,
                c2 = col + dc;
              if (
                r2 >= 0 &&
                r2 < 8 &&
                c2 >= 0 &&
                c2 < 8 &&
                isEnemy(board[r2][c2], white)
              ) {
                moves.push([r2, c2]);
              }
            }
            break;
          case "r":
            for (let d of [
              [0, 1],
              [1, 0],
              [0, -1],
              [-1, 0],
            ])
              addDirection(...d);
            break;
          case "b":
            for (let d of [
              [1, 1],
              [1, -1],
              [-1, 1],
              [-1, -1],
            ])
              addDirection(...d);
            break;
          case "q":
            for (let d of [
              [0, 1],
              [1, 0],
              [0, -1],
              [-1, 0],
              [1, 1],
              [1, -1],
              [-1, 1],
              [-1, -1],
            ])
              addDirection(...d);
            break;
          case "k":
            for (let dr = -1; dr <= 1; dr++)
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const r2 = row + dr,
                  c2 = col + dc;
                if (
                  r2 >= 0 &&
                  r2 < 8 &&
                  c2 >= 0 &&
                  c2 < 8 &&
                  !isFriend(board[r2][c2], white)
                ) {
                  moves.push([r2, c2]);
                }
              }
            if (white) {
              if (canCastle(true, true)) moves.push([7, 6]);
              if (canCastle(true, false)) moves.push([7, 2]);
            } else {
              if (canCastle(false, true)) moves.push([0, 6]);
              if (canCastle(false, false)) moves.push([0, 2]);
            }
            break;
          case "n":
            const offsets = [
              [-2, -1],
              [-2, 1],
              [-1, -2],
              [-1, 2],
              [1, -2],
              [1, 2],
              [2, -1],
              [2, 1],
            ];
            for (let i = 0; i < offsets.length; i++) {
              const [dr, dc] = offsets[i];
              const r2 = row + dr,
                c2 = col + dc;
              if (
                r2 >= 0 &&
                r2 < 8 &&
                c2 >= 0 &&
                c2 < 8 &&
                !isFriend(board[r2][c2], white)
              ) {
                moves.push([r2, c2]);
              }
            }
            break;
        }
        return moves;
      }

      function getShootTargets(row, col, piece) {
        const targets = [];
        const white = isWhite(piece);
        const type = piece.toLowerCase();

        function addShootDirection(dr, dc) {
          let r = row + dr,
            c = col + dc;
          while (r >= 0 && r < 8 && c >= 0 && c < 8) {
            if (board[r][c] !== null) {
              if (isEnemy(board[r][c], white)) targets.push([r, c]);
              break;
            }
            r += dr;
            c += dc;
          }
        }

        switch (type) {
          case "p":
            const dir = white ? -1 : 1;
            for (let dc of [-1, 1]) {
              const r2 = row + dir,
                c2 = col + dc;
              if (
                r2 >= 0 &&
                r2 < 8 &&
                c2 >= 0 &&
                c2 < 8 &&
                isEnemy(board[r2][c2], white)
              ) {
                targets.push([r2, c2]);
              }
            }
            break;
          case "r":
            for (let d of [
              [0, 1],
              [1, 0],
              [0, -1],
              [-1, 0],
            ])
              addShootDirection(...d);
            break;
          case "b":
            for (let d of [
              [1, 1],
              [1, -1],
              [-1, 1],
              [-1, -1],
            ])
              addShootDirection(...d);
            break;
          case "q":
            for (let d of [
              [0, 1],
              [1, 0],
              [0, -1],
              [-1, 0],
              [1, 1],
              [1, -1],
              [-1, 1],
              [-1, -1],
            ])
              addShootDirection(...d);
            break;
          case "k":
            for (let dr = -1; dr <= 1; dr++)
              for (let dc = -1; dc <= 1; dc++) {
                if (dr === 0 && dc === 0) continue;
                const r2 = row + dr,
                  c2 = col + dc;
                if (
                  r2 >= 0 &&
                  r2 < 8 &&
                  c2 >= 0 &&
                  c2 < 8 &&
                  isEnemy(board[r2][c2], white)
                ) {
                  targets.push([r2, c2]);
                }
              }
            break;
          case "n":
            const offsets = [
              [-2, -1],
              [-2, 1],
              [-1, -2],
              [-1, 2],
              [1, -2],
              [1, 2],
              [2, -1],
              [2, 1],
            ];
            for (let i = 0; i < offsets.length; i++) {
              const [dr, dc] = offsets[i];
              const r2 = row + dr,
                c2 = col + dc;
              if (
                r2 >= 0 &&
                r2 < 8 &&
                c2 >= 0 &&
                c2 < 8 &&
                isEnemy(board[r2][c2], white)
              ) {
                targets.push([r2, c2]);
              }
            }
            break;
        }
        return targets;
      }

      function updateCastling(fromRow, fromCol, toRow, toCol, piece) {
        if (piece === "K") {
          castling.whiteKingside = false;
          castling.whiteQueenside = false;
        }
        if (piece === "k") {
          castling.blackKingside = false;
          castling.blackQueenside = false;
        }
        if (piece === "R") {
          if (fromCol === 0) castling.whiteQueenside = false;
          if (fromCol === 7) castling.whiteKingside = false;
        }
        if (piece === "r") {
          if (fromCol === 0) castling.blackQueenside = false;
          if (fromCol === 7) castling.blackKingside = false;
        }
      }

      // === –ö–õ–Æ–ß–ï–í–ê–Ø –§–£–ù–ö–¶–ò–Ø: –•–û–î –° üèπ ===
      function makeMove(fromRow, fromCol, toRow, toCol) {
        const piece = board[fromRow][fromCol];
        const captured = board[toRow][toCol] !== null;
        let notation = "";

        const cols = "abcdefgh";
        const toColChar = cols[toCol];
        const toRank = 8 - toRow;

        // –†–æ–∫–∏—Ä–æ–≤–∫–∞
        if (piece === "K" && fromRow === 7 && fromCol === 4) {
          if (toCol === 6) {
            board[7][5] = "R";
            board[7][7] = null;
            notation = "O-O";
          } else if (toCol === 2) {
            board[7][3] = "R";
            board[7][0] = null;
            notation = "O-O-O";
          }
        } else if (piece === "k" && fromRow === 0 && fromCol === 4) {
          if (toCol === 6) {
            board[0][5] = "r";
            board[0][7] = null;
            notation = "O-O";
          } else if (toCol === 2) {
            board[0][3] = "r";
            board[0][0] = null;
            notation = "O-O-O";
          }
        }

        if (!notation) {
          const pieceChar =
            piece.toLowerCase() === "p" ? "" : piece.toUpperCase();
          if (captured) {
            notation = `${pieceChar}üèπ${toColChar}${toRank}`;
          } else {
            notation = `${pieceChar}${toColChar}${toRank}`;
          }
        }

        board[toRow][toCol] = piece;
        board[fromRow][fromCol] = null;
        updateCastling(fromRow, fromCol, toRow, toCol, piece);
        addToPGN(notation);
      }

      // === –û—Å—Ç–∞–ª—å–Ω–æ–π –∫–æ–¥ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π ===
      function playShootSound() {
        try {
          const audioCtx = new (window.AudioContext ||
            window.webkitAudioContext)();
          const oscillator = audioCtx.createOscillator();
          const gainNode = audioCtx.createGain();
          oscillator.connect(gainNode);
          gainNode.connect(audioCtx.destination);
          oscillator.type = "square";
          oscillator.frequency.setValueAtTime(300, audioCtx.currentTime);
          oscillator.frequency.exponentialRampToValueAtTime(
            800,
            audioCtx.currentTime + 0.1
          );
          oscillator.frequency.exponentialRampToValueAtTime(
            200,
            audioCtx.currentTime + 0.2
          );
          gainNode.gain.setValueAtTime(0.3, audioCtx.currentTime);
          gainNode.gain.exponentialRampToValueAtTime(
            0.01,
            audioCtx.currentTime + 0.3
          );
          oscillator.start(audioCtx.currentTime);
          oscillator.stop(audioCtx.currentTime + 0.3);
        } catch (e) {
          console.warn("–ó–≤—É–∫ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è:", e);
        }
      }

      function showBlood(row, col) {
        const square = document.querySelector(
          `.square[data-row="${row}"][data-col="${col}"]`
        );
        if (!square) return;
        const blood = document.createElement("div");
        blood.className = "blood";
        blood.textContent = "‚óè";
        blood.style.left = "50%";
        blood.style.top = "50%";
        blood.style.transform = "translate(-50%, -50%)";
        square.appendChild(blood);
        setTimeout(() => {
          if (blood.parentNode) blood.parentNode.removeChild(blood);
        }, 1000);
      }

      function shootLaser(fromRow, fromCol, toRow, toCol) {
        const boardEl = document.getElementById("chessboard");
        const from = document.querySelector(
          `.square[data-row="${fromRow}"][data-col="${fromCol}"]`
        );
        const to = document.querySelector(
          `.square[data-row="${toRow}"][data-col="${toCol}"]`
        );
        if (!from || !to) return;
        const fromRect = from.getBoundingClientRect();
        const toRect = to.getBoundingClientRect();
        const boardRect = boardEl.getBoundingClientRect();
        const x1 = fromRect.left + fromRect.width / 2 - boardRect.left;
        const y1 = fromRect.top + fromRect.height / 2 - boardRect.top;
        const x2 = toRect.left + toRect.width / 2 - boardRect.left;
        const y2 = toRect.top + toRect.height / 2 - boardRect.top;
        const length = Math.sqrt((x2 - x1) ** 2 + (y2 - y1) ** 2);
        const angle = (Math.atan2(y2 - y1, x2 - x1) * 180) / Math.PI;
        const laser = document.createElement("div");
        laser.className = "laser";
        laser.style.left = x1 + "px";
        laser.style.top = y1 + "px";
        laser.style.width = "0px";
        laser.style.transform = `rotate(${angle}deg)`;
        laser.style.setProperty("--laser-length", length + "px");
        boardEl.appendChild(laser);
        setTimeout(() => {
          if (laser.parentNode) laser.parentNode.removeChild(laser);
        }, 300);
      }

      function clearHighlights() {
        document
          .querySelectorAll(".highlight, .move-possible, .target")
          .forEach((el) => {
            el.classList.remove("highlight", "move-possible", "target");
          });
        selectedPiece = null;
        mode = null;
        possibleMoves = [];
        shootTargets = [];
      }

      function renderBoard() {
        const boardEl = document.getElementById("chessboard");
        boardEl.innerHTML = "";
        for (let row = 0; row < 8; row++) {
          for (let col = 0; col < 8; col++) {
            const square = document.createElement("div");
            square.className = `square ${
              (row + col) % 2 === 0 ? "white" : "black"
            }`;
            square.dataset.row = row;
            square.dataset.col = col;
            const piece = board[row][col];
            if (piece) {
              square.textContent = pieceSymbols[piece];
              square.className += isWhite(piece)
                ? " piece-white"
                : " piece-black";
            }
            square.addEventListener("mousedown", (e) => {
              e.preventDefault();
              handleSquareClick(row, col, e.button);
            });
            boardEl.appendChild(square);
          }
        }

        if (selectedPiece) {
          const [r, c] = selectedPiece;
          document
            .querySelector(`.square[data-row="${r}"][data-col="${c}"]`)
            .classList.add("highlight");
        }
        for (const [r, c] of possibleMoves) {
          document
            .querySelector(`.square[data-row="${r}"][data-col="${c}"]`)
            .classList.add("move-possible");
        }
        for (const [r, c] of shootTargets) {
          document
            .querySelector(`.square[data-row="${r}"][data-col="${c}"]`)
            .classList.add("target");
        }
      }

      function checkKingAlive() {
        const enemyKing = currentPlayer === "white" ? "k" : "K";
        for (let r = 0; r < 8; r++)
          for (let c = 0; c < 8; c++) {
            if (board[r][c] === enemyKing) return true;
          }
        return false;
      }

      function handleSquareClick(row, col, button) {
        const piece = board[row][col];
        const isOwnPiece =
          (currentPlayer === "white" && isWhite(piece)) ||
          (currentPlayer === "black" && isBlack(piece));

        if (button === 2) {
          if (mode === "shoot" && selectedPiece) {
            const isValidTarget = shootTargets.some(
              (t) => t[0] === row && t[1] === col
            );
            if (isValidTarget) {
              playShootSound();
              const [fromR, fromC] = selectedPiece;
              shootLaser(fromR, fromC, row, col);
              setTimeout(() => {
                logShot(fromR, fromC, row, col);
                board[row][col] = null;
                showBlood(row, col);

                if (!checkKingAlive()) {
                  const winner = currentPlayer === "white" ? "–ë–µ–ª—ã–µ" : "–ß—ë—Ä–Ω—ã–µ";
                  document.getElementById(
                    "status"
                  ).textContent = `‚ò†Ô∏è ${winner} –ø–æ–±–µ–¥–∏–ª–∏! –ö–æ—Ä–æ–ª—å —É–Ω–∏—á—Ç–æ–∂–µ–Ω.`;
                  setTimeout(
                    () => alert(`${winner} –ø–æ–±–µ–¥–∏–ª–∏!\n–ö–æ—Ä–æ–ª—å —É–±–∏—Ç.`),
                    100
                  );
                  clearHighlights();
                  renderBoard();
                  return;
                }

                currentPlayer = currentPlayer === "white" ? "black" : "white";
                document.getElementById("status").textContent =
                  currentPlayer === "white" ? "–•–æ–¥ –±–µ–ª—ã—Ö" : "–•–æ–¥ —á—ë—Ä–Ω—ã—Ö";
                clearHighlights();
                renderBoard();
              }, 300);
              return;
            } else {
              clearHighlights();
              renderBoard();
              return;
            }
          }

          if (isOwnPiece) {
            clearHighlights();
            selectedPiece = [row, col];
            shootTargets = getShootTargets(row, col, piece);
            mode = "shoot";
            renderBoard();
            return;
          }

          clearHighlights();
          renderBoard();
          return;
        }

        if (button === 0) {
          if (mode === "move" && selectedPiece) {
            const isValidMove = possibleMoves.some(
              (m) => m[0] === row && m[1] === col
            );
            if (isValidMove) {
              const [fromR, fromC] = selectedPiece;
              const captured = board[row][col] !== null;

              makeMove(fromR, fromC, row, col); // ‚úÖ –ó–∞–ø–∏—Å—å —Ö–æ–¥–∞

              if (captured) showBlood(row, col);

              if (!checkKingAlive()) {
                const winner = currentPlayer === "white" ? "–ë–µ–ª—ã–µ" : "–ß—ë—Ä–Ω—ã–µ";
                document.getElementById(
                  "status"
                ).textContent = `‚öîÔ∏è ${winner} –ø–æ–±–µ–¥–∏–ª–∏!`;
                setTimeout(() => alert(`${winner} –ø–æ–±–µ–¥–∏–ª–∏!`), 100);
                clearHighlights();
                renderBoard();
                return;
              }

              currentPlayer = currentPlayer === "white" ? "black" : "white";
              document.getElementById("status").textContent =
                currentPlayer === "white" ? "–•–æ–¥ –±–µ–ª—ã—Ö" : "–•–æ–¥ —á—ë—Ä–Ω—ã—Ö";
              clearHighlights();
              renderBoard();
              return;
            } else {
              clearHighlights();
              renderBoard();
              return;
            }
          }

          if (isOwnPiece) {
            clearHighlights();
            selectedPiece = [row, col];
            possibleMoves = getValidMoves(row, col, piece);
            mode = "move";
            renderBoard();
            return;
          }

          clearHighlights();
          renderBoard();
          return;
        }
      }

      document.getElementById("pgn-button").addEventListener("click", () => {
        const win = document.getElementById("pgn-window");
        win.style.display = win.style.display === "none" ? "flex" : "none";
        if (win.style.display === "flex") updatePGNDisplay();
      });

      document.getElementById("pgn-close").addEventListener("click", () => {
        document.getElementById("pgn-window").style.display = "none";
      });

      let isDragging = false;
      let dragOffsetX, dragOffsetY;
      const header = document.getElementById("pgn-header");
      const win = document.getElementById("pgn-window");

      header.addEventListener("mousedown", (e) => {
        isDragging = true;
        const rect = win.getBoundingClientRect();
        dragOffsetX = e.clientX - rect.left;
        dragOffsetY = e.clientY - rect.top;
        e.preventDefault();
      });

      document.addEventListener("mousemove", (e) => {
        if (isDragging) {
          win.style.left = e.clientX - dragOffsetX + "px";
          win.style.top = e.clientY - dragOffsetY + "px";
          win.style.right = "auto";
          win.style.bottom = "auto";
        }
      });

      document.addEventListener("mouseup", () => {
        isDragging = false;
      });

      document.addEventListener("contextmenu", (e) => e.preventDefault());
      renderBoard();
    </script>
  </body>
</html>
